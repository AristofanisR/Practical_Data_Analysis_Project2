---
title: | 
 \textbf{TBD}

 \vspace{1cm} 
subtitle: 
 "Practical Data Analysis - Project 2: Regression Analysis"
author: "Aristofanis Rontogiannis"
date: "2024-11-04"
output:
  pdf_document: 
    latex_engine: xelatex
    keep_tex: true
bibliography: References.bib
link-citations: yes
---

# Abstract

**Purpose**:

**Methods**:

**Results**:

**Conclusions**:

# Introduction

@hitsman2023efficacy

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = FALSE,
                  message = FALSE,
                  warning = FALSE,
                  error = FALSE)

library(summarytools)
library(ggplot2)
library(knitr)
library(kableExtra)
library(GGally)
library(patchwork)
library(dplyr)
library(reshape2)
library(tidyr)
library(grid)
library(lubridate)
library(gtsummary)
library(gt)
library(ggcorrplot)
library(glmnet)
library(bestglm)
library(MASS)
library(pROC)
library(gridExtra)
library(VIM)
library(mice)
library(leaps)
```

```{r}
#Read main data set 
data<-read.csv("project2.csv") 

# Data processing
data = data  %>%
  # create race variable
  mutate(race = factor(case_when(
    NHW == 1 ~ "Non-Hispanic White",
    Black == 1 ~ "Black",
    Hisp == 1 ~ "Hispanic",
    TRUE ~ "Other"  # Handle cases where none of the above conditions are met
  ), levels = c("Non-Hispanic White", "Black", "Hispanic", "Other"))) %>%
  # create treatment categories
  mutate(treatment_cat = factor(case_when(BA == 1 & Var == 0 ~ "BASC+placebo",
                                   BA == 0 & Var == 0 ~ "ST+placebo",
                                   BA == 1 & Var == 1 ~ "BASC+varenicline",
                                   BA == 0 & Var == 1 ~ "ST+varenicline"))) %>%
  # Change variables attributes to be only Numeric or Factor at the end
  #Factor
  mutate(
    abst = factor(abst),
    Var = factor(Var),
    BA = factor(BA),
    sex_ps = factor(sex_ps),
    ftcd.5.mins = factor(ftcd.5.mins),
    otherdiag = factor(otherdiag),
    antidepmed = factor(antidepmed),
    mde_curr = factor(mde_curr),
    Only.Menthol = factor(Only.Menthol),
    edu = factor(edu, levels = c(1, 2, 3, 4, 5)),
    inc = factor(inc, levels = c(1, 2, 3, 4, 5))
  ) %>%
 #Numeric (except id)
  mutate(across(
    .cols = where(is.numeric) & !all_of("id"),
    .fns = as.numeric
  ))

```

\newpage
\begin{landscape}
```{r}
# Summary Table
table1_data = data %>%
  mutate(edu = factor(edu, levels = c(1, 2, 3, 4, 5),
                 labels = c("     Grade school",
                            "     Some high school",
                            "     High school graduate or GED",
                            "     Some college/technical school",
                            "     College graduate")),
    inc = factor(inc, levels = c(1, 2, 3, 4, 5),
                 labels = c("     Less than $20,000",
                            "     $20,000–$35,000",
                            "     $35,001–$50,000",
                            "     $50,001–$75,000",
                            "     More than $75,000")),
    race = factor(race, labels = c("    Non-Hispanic White",
                                   "    Black",
                                   "    Hispanic",
                                   "    Other"))
    )

# Demographics table
demographics_table <- table1_data %>%
  dplyr::select(
    treatment_cat,
    age_ps,
    sex_ps,
    race,
    inc,
    edu
  ) %>%
  tbl_summary(
    by = treatment_cat,
    label = list(
      age_ps = "Age (years)",
      sex_ps = "Sex (Female)",
      race = "Race",
      inc = "Income",
      edu = "Education"
    ),
    type = list(
      age_ps ~ "continuous",
      sex_ps ~ "dichotomous",
      race ~ "categorical",
      inc ~ "categorical",
      edu ~ "categorical"),
    value = list(
      sex_ps ~ "2"),
    statistic = list(all_continuous() ~ "{mean} ({sd})", 
                     all_categorical() ~ "{n} ({p}%)"),
    digits = all_continuous() ~ 1,
    missing = "no"
  ) %>% add_overall() 
# %>%
# modify_column_indent(columns = label,
# rows = !row_type %in% "label",
# indent = 4L)

# Smoking table
smoking_table <- table1_data %>%
  dplyr::select(
    treatment_cat,
    cpd_ps,
    ftcd_score,
    ftcd.5.mins,
    bdi_score_w00,
    crv_total_pq1,
    hedonsum_n_pq1,
    hedonsum_y_pq1,
    Only.Menthol,
    readiness,
    NMR
  ) %>%
  tbl_summary(
    by = treatment_cat,
    label = list(
      cpd_ps = "Cigarettes per day at baseline phone survey",
      ftcd_score = "FTCD score at baseline",
      ftcd.5.mins = "Smoking within 5 mins of waking up (Yes)",
      bdi_score_w00 = "BDI score at baseline",
      crv_total_pq1 = "Cigarette reward value at baseline",
      hedonsum_n_pq1 = "Pleasurable Events Scale - substitute reinforcers",
      hedonsum_y_pq1 = "Pleasurable Events Scale - complementary reinforcers",
      Only.Menthol = "Exclusive Mentholated Cigarette User (Yes)",
      readiness = "Readiness to quit smoking",
      NMR = "Nicotine Metabolism Ratio"
    ), type = list(
      cpd_ps ~ "continuous",
      ftcd_score ~ "continuous",
      ftcd.5.mins ~ "dichotomous",
      bdi_score_w00 ~ "continuous",
      crv_total_pq1 ~ "continuous",
      hedonsum_n_pq1 ~ "continuous",
      hedonsum_y_pq1 ~ "continuous",
      NMR ~ "continuous",
      Only.Menthol ~ "dichotomous",
      readiness ~ "continuous"),
    value = list(
      Only.Menthol ~ "1",
      ftcd.5.mins ~ "1"),
    statistic = list(all_continuous() ~ "{mean} ({sd})", all_categorical() ~ "{n} ({p}%)"),
    digits = all_continuous() ~ 1,
    missing = "no"
  ) %>% add_overall()
# %>%
#   modify_header(label ~ "Smoking")

# Psychiatric table
psychiatric_table <- table1_data %>%
  dplyr::select(
    treatment_cat,
    shaps_score_pq1,
    otherdiag,
    antidepmed,
    mde_curr
  ) %>%
  tbl_summary(
    by = treatment_cat,
    label = list(
      shaps_score_pq1 = "Anhedonia",
      otherdiag = "Other lifetime DSM-5 diagnosis (Yes)",
      antidepmed = "Taking antidepressant medication at baseline (Yes)",
      mde_curr = "Current vs past MDD (Yes)"
    ),
    type = list(shaps_score_pq1 ~ "continuous",
      otherdiag ~ "dichotomous",
      antidepmed ~ "dichotomous",
      mde_curr ~ "dichotomous"),
    value = list(otherdiag ~ "1",
      antidepmed ~ "1",
      mde_curr ~ "1"),
    statistic = list(all_continuous() ~ "{mean} ({sd})", 
                     all_categorical() ~ "{n} ({p}%)"),
    digits = all_continuous() ~ 1,
    missing = "no"
  ) %>% add_overall() 
# %>%
#   modify_header(label ~ "Psychiatric")

# Merge tables
final_table <- tbl_stack(
  tbls = list(demographics_table, smoking_table, psychiatric_table),
  group_header = c("Demographics", "Smoking", "Psychiatric")
) %>%
  modify_caption("Participant characteristics by treatment and overall sample") %>%
  as_kable_extra(
    booktabs = TRUE,
    longtable = TRUE,
    linesep = "",
    format = "latex"
  ) %>%
  kable_styling(
    position = "center",
    latex_options = c("striped", "repeat_header"),
    stripe_color = "gray!15",
    font_size = 8
  )


final_table
```
\end{landscape}
\newpage


```{r}
#Missingness Table
# Calculate missing values for each variable
missing_summary <- data %>%
  summarise(across(everything(), ~ sum(is.na(.)), .names = "missing_{col}")) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "Number") %>%
  mutate(Pct = (Number / nrow(data)) * 100) %>%
  filter(Number > 0)  # Exclude variables with 0 missingness

# Define a named vector with old and new names for variables
variable_names <- c(
  "inc" = "Income",
  "ftcd_score" = "FTCD Score",
  "crv_total_pqr" = "Cigarette reward at baseline",
  "shaps_score_pqi" = "Anhedonia",
  "NMR" = "Nicotine MEtabolism Ratio",
  "Only.Menthol" = "Exclusive Mentholated Cigarette User",
  "readiness" = "Baseline readiness to quit smoking"
)

# Rename variables in the summary table
missing_summary <- missing_summary %>%
  mutate(Variable = recode(Variable, !!!variable_names))

# Load knitr for table formatting (optional)
library(knitr)

# Create and display the table
missing_summary %>%
  arrange(desc(Pct)) %>%
  mutate(Pct = sprintf("%.2f%%", Pct)) %>%
  kable(col.names = c("Variable", "Number", "Pct"), caption = "Table 1: Summary 
        of Missing Values")
```


```{r}
# Create a new variable that contains the 3 first levels of edu
data <- data %>%
  mutate(edu_merged = factor(case_when(
    edu %in% c("1", "2", "3") ~ "1",
    edu == "4" ~ "2",
    edu == "5" ~ "3"
  )))


```

```{r}
# Second Method: MICE 
# Perform MICE imputation
data_mice <- mice(data, m = 5
                  , method = "pmm", maxit = 50, seed = 58, printFlag= FALSE)

# Complete the data by extracting one of the imputed datasets
data_mice <- complete(data_mice, action = 4)
```

```{r}
# Check the relationship between Menthol Cigarettes and Race
table_race_menthol <- table(data_mice$race, data_mice$Only.Menthol)

# Chi-square test
chi_square_test <- chisq.test(table_race_menthol) #p-value too small
#We reject the null hypothesis (which is there is no association)

chi_square_test_note <- paste0(
  sprintf("Chi-Square Statistic: %.4f", chi_square_test$statistic), 
  sprintf(", p-value : Approaching %.4f", chi_square_test$p.value)
)

kable(table_race_menthol,
      caption = "Contingency Table of Only Menthol Use and Race",
      col.names = c("Non-Menthol", "Menthol"),
      row.names = TRUE,
      format = "markdown")  %>%
  footnote(chi_square_test_note, footnote_as_chunk = FALSE)

```

# Data Analysis

```{r}
# Modeling Preprocessing
# Define the outcome and variables in the model
outcome <- data_mice$abst
variable_names <- c("Var", "BA", "age_ps", "sex_ps", "inc", "edu_merged", "race",
                     "ftcd_score", "ftcd.5.mins", "bdi_score_w00", "cpd_ps",
                     "crv_total_pq1", "hedonsum_n_pq1", "hedonsum_y_pq1",
                     "shaps_score_pq1", "otherdiag", "antidepmed", "mde_curr",
                     "NMR", "Only.Menthol", "readiness")
variables <- data_mice[, variable_names]
# for Lasso (to break down factors with >2 levels)
variables_dummy <- model.matrix(~ 0 + ., data = variables)
# remove the extra reference group
variables_dummy <- variables_dummy[, -which(colnames(variables_dummy) =="Var0")]

# Split into train and test
set.seed(58)
train_index <- sample(1:nrow(data_mice), 0.7 * nrow(data_mice))
train_data <- data_mice[train_index,]
test_data <- data_mice[-train_index,]
train_outcome <- outcome[train_index]
test_outcome <- outcome[-train_index]

# for Lasso
train_variables_dummy <- variables_dummy[train_index, ]
test_variables_dummy <- variables_dummy[-train_index, ]

# for best subset (we will do this next)
train_variables <- variables[train_index, ]
test_variables <- variables[-train_index, ]

train_data_glmnet = data.frame(abst = train_outcome, train_variables_dummy)
test_data_glmnet = data.frame(abst = test_outcome, test_variables_dummy)

# We have to keep BA and Var with 0 penalty
# Lasso Regression
# ^2 generates all pairwise interactions
train_variables_dummy_df <- as.data.frame(train_variables_dummy)
train_variables_dummy_full_interactions <- model.matrix(~ .^2,
                                              data = train_variables_dummy_df)
test_variables_dummy_df <- as.data.frame(test_variables_dummy)
test_variables_dummy_full_interactions <- model.matrix(~ .^2,
                                               data = test_variables_dummy_df)



train_variables_dummy_include_names <- c(
  "Var1", "BA1", "age_ps", "sex_ps2", "inc2", "inc3",
  "inc4", "inc5", "edu_merged2", "edu_merged3",
  "raceBlack", "raceHispanic", "raceOther",
  "ftcd_score", "ftcd.5.mins1", "bdi_score_w00", "cpd_ps",
  "crv_total_pq1", "hedonsum_n_pq1", "hedonsum_y_pq1",              
  "shaps_score_pq1", "otherdiag1", "antidepmed1",                  
  "mde_curr1", "NMR", "Only.Menthol1",                
  "readiness", "Var1:BA1", "BA1:mde_curr1",
  "BA1:age_ps", "BA1:sex_ps2",
  "BA1:raceBlack", "BA1:raceHispanic",
  "BA1:raceOther", "BA1:ftcd_score", "BA1:cpd_ps",
  "Var1:age_ps", "Var1:sex_ps2",
  "Var1:raceBlack", "Var1:raceHispanic",
  "Var1:raceOther", "Var1:ftcd_score", "Var1:cpd_ps",
   "inc2:edu_merged2", "inc2:edu_merged3",
  "inc3:edu_merged2", "inc3:edu_merged3",
  "inc4:edu_merged2", "inc4:edu_merged3",
  "inc5:edu_merged2", "inc5:edu_merged3",
  "antidepmed1:readiness", "Only.Menthol1:readiness",
  "mde_curr1:readiness", "ftcd.5.mins1:readiness",
  "bdi_score_w00:readiness", "Var1:shaps_score_pq1",
  "BA1:shaps_score_pq1", "shaps_score_pq1:mde_curr1",
  "sex_ps2:ftcd_score", "raceBlack:ftcd_score",
  "raceHispanic:ftcd_score", "raceOther:ftcd_score",
  "age_ps:ftcd_score", "sex_ps2:Only.Menthol1", 
  "raceBlack:Only.Menthol1", "raceHispanic:Only.Menthol1", 
  "raceOther:Only.Menthol1",
  "inc2:Only.Menthol1", "inc3:Only.Menthol1",
  "inc4:Only.Menthol1", "inc5:Only.Menthol1",
  "edu_merged2:Only.Menthol1", "edu_merged3:Only.Menthol1",
  "sex_ps2:NMR", "age_ps:NMR", "cpd_ps:NMR",
  "NMR:readiness", "ftcd_score:NMR"
)

train_variables_dummy_include = train_variables_dummy_full_interactions[,train_variables_dummy_include_names]

test_variables_dummy_include = test_variables_dummy_full_interactions[,train_variables_dummy_include_names]

# Initialize penalty factors to 1 for all variables
penalty_factors <- rep(1, ncol(train_variables_dummy_include))

# Identify columns corresponding exactly to "Var1" and "BA1" (not their interactions)
var1_col <- grep("^Var1$", colnames(train_variables_dummy_include))
ba1_col <- grep("^BA1$", colnames(train_variables_dummy_include))

penalty_factors[c(var1_col, ba1_col)] <- 0
names(penalty_factors) <- colnames(train_variables_dummy_include)

set.seed(58)
lasso_model <- cv.glmnet(as.matrix(train_variables_dummy_include), train_outcome,
                         penalty.factor = penalty_factors,
                         alpha = 1, family = "binomial")

# Extract coefficients at the optimal lambda (best_lambda)
best_lambda_lasso <- lasso_model$lambda.min
#remove intercept
optimal_coefs_lasso <- as.numeric(coef(lasso_model, s = best_lambda_lasso)[-1])
coef_names_lasso <- rownames(coef(lasso_model, s = best_lambda_lasso))[-1]  

result_table_lasso <- data.frame(
  variable = coef_names_lasso,
  Coefficient = optimal_coefs_lasso
) %>%
  filter(Coefficient != 0)

```

```{r}
# Logistic regression

# Define outcome and predictor variables
outcome <- data_mice$abst
variable_names <- c("Var", "BA", "age_ps", "sex_ps", "inc", "edu_merged", 
                    "race",
                    "ftcd_score", "ftcd.5.mins", "bdi_score_w00", "cpd_ps",
                    "crv_total_pq1", "hedonsum_n_pq1", "hedonsum_y_pq1",
                    "shaps_score_pq1", "otherdiag", "antidepmed", "mde_curr",
                    "NMR", "Only.Menthol", "readiness")

# Prepare the dataset
variables <- data_mice[, variable_names]
variables$Var <- factor(variables$Var)
variables$BA <- factor(variables$BA)

# Main effects for `Var` and `BA` (to be controlled in all models)
main_effects <- paste(c("Var", "BA", "age_ps", "sex_ps", "inc", 
                        "edu_merged", "race",
                        "ftcd_score", "ftcd.5.mins", "bdi_score_w00", 
                        "cpd_ps",
                        "crv_total_pq1", "hedonsum_n_pq1", 
                        "hedonsum_y_pq1",
                        "shaps_score_pq1", "otherdiag", "antidepmed", 
                        "mde_curr",
                        "NMR", "Only.Menthol", "readiness"), 
                      collapse = " + ")

# Define the interaction terms we want to consider
interaction_terms <- paste(
  "BA:mde_curr + BA:age_ps + BA:sex_ps + BA:race + BA:ftcd_score + BA:cpd_ps",
  "Var:age_ps + Var:sex_ps + Var:race + Var:ftcd_score + Var:cpd_ps",
  "inc:edu_merged + antidepmed:readiness + Only.Menthol:readiness + 
  mde_curr:readiness",
  "ftcd.5.mins:readiness + bdi_score_w00:readiness + Var:shaps_score_pq1 + 
  BA:shaps_score_pq1",
  "shaps_score_pq1:mde_curr + sex_ps:ftcd_score + race:ftcd_score + 
  age_ps:ftcd_score",
  "sex_ps:Only.Menthol + race:Only.Menthol + inc:Only.Menthol + 
  edu_merged:Only.Menthol",
  "sex_ps:NMR + age_ps:NMR + cpd_ps:NMR + NMR:readiness + ftcd_score:NMR",
  sep = " + "
)

# Full formula for main effects and interactions
full_formula <- as.formula(paste("abst ~", main_effects,
                                 "+", interaction_terms))

# Define scope with `Var` and `BA` as forced terms in the main model
scope_list <- list(
  lower = as.formula("abst ~ Var + BA"),  # Minimal model with controlled terms
  upper = full_formula         # Full model with all main and interaction terms
)

# Fit logistic regression model with stepwise selection
set.seed(58)
logistic_model <- step(
  glm(formula = abst ~ Var + BA, data = train_data, family = "binomial"),
  scope = scope_list,
  direction = "both",
  trace=0
)

# Display the summary of the final model
#summary(logistic_model)
```



```{r}
# Best subset selection

# Run best subset selection with regsubsets
best_subset_model <- regsubsets(
  y = train_outcome, x = train_variables_dummy_include,
  force.in = c("Var1", "BA1"), nbest = 1, 
  nvmax = 100,  # Adjust this based on how many variables you want to consider
  method = "seq", force.out = NULL,
  really.big=T
)

# Summarize results
best_subset_summary <- summary(best_subset_model)
best_subset_summary = summary(best_subset_model)
cp_min = which.min(best_subset_summary$cp) # min is 10
best_subset_coefs = coef(best_subset_model, cp_min)
best_subset_names = names(coef(best_subset_model, cp_min))
```


```{r}
# Create a table with coefficients from Logistic, Lasso, Best Subset Selection

# Logistic coefficients
stepwise_coefs <- coef(logistic_model)
stepwise_df <- data.frame(
  variable = names(stepwise_coefs),
  `Stepwise` = as.numeric(stepwise_coefs)
)

# Lasso coefficients
lasso_df <- result_table_lasso %>%
  rename(`Lasso` = Coefficient)

# Best subset coefficients
best_subset_df <- data.frame(
  variable = names(best_subset_coefs),
  `Best Subset` = as.numeric(best_subset_coefs)
)

# Merge all into one table based on variable names
combined_df <- full_join(lasso_df, stepwise_df, by = "variable") %>%
  full_join(best_subset_df, by = "variable") %>%
  mutate(across(where(is.numeric), ~ round(.x, 6)))

# Remove the intercept row
combined_df <- combined_df[combined_df$variable != "(Intercept)", ]

# Replace NA values with an empty space
combined_df[is.na(combined_df)] <- " "

colnames(combined_df) <- gsub("Best.Subset", "Best Subset", colnames(combined_df))

# Change "variable" to "Variables" in the combined_df
colnames(combined_df)[colnames(combined_df) == "variable"] <- "Variables"

# Display the final combined table
kable(combined_df, row.names = FALSE,
      caption = "Summary of Coefficients for Moderator Effects across 3 Selection Methods")


# Display the final combined table
kable(combined_df, row.names = F,
      caption = "Summary of Coefficients for Moderator Effects across 3 Selection Methods")
```


```{r}
# Roc/Auc
predicted_prob_lasso <- predict(lasso_model,
                                newx = as.matrix(test_variables_dummy_include),
                                s = "lambda.min", type = "response")

# Convert predictions to numeric if needed (glmnet returns a matrix)
predicted_prob_lasso <- as.numeric(predicted_prob_lasso)

# Plot ROC and calculate AUC
# Generate ROC object
roc_obj <- roc(test_outcome, predicted_prob_lasso)

# Convert the ROC object to a data frame for ggplot2
roc_data <- data.frame(
  Specificity = rev(roc_obj$specificities),
  Sensitivity = rev(roc_obj$sensitivities)
)

# Calculate the AUC
auc_value <- auc(roc_obj)

# Plot ROC curve with ggplot2
ROC_lasso = ggplot(roc_data, aes(x = 1-Specificity, y = Sensitivity)) +
  geom_line(color = "purple", size = 1) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "grey") +
  annotate("text", x = 0.8, y = 0.2, label = paste("AUC =", 
  round(auc_value, 2)), 
  size = 5, color = "Black") +
  labs(
    x = "1 - Specificity",
    y = "Sensitivity"
  ) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5), 
        plot.subtitle = element_text(hjust = 0.5))
```


```{r, fig.width = 12, fig.height = 4}
# Calibration Plots
num_cuts <- 10  # Number of bins for calibration

calib_data <- data.frame(
  prob = predicted_prob_lasso,  # predicted probabilities
  # binning into `num_cuts` groups
  bin = cut(predicted_prob_lasso, breaks = num_cuts),  
  # observed values (abst outcome in test data)
  class = as.numeric(test_outcome)-1  
)

calib_data <- calib_data %>%
  group_by(bin) %>%
  summarise(
    observed = mean(class),  
    predicted = mean(prob),  
    se = sqrt(observed * (1 - observed) / n())  # Standard error
  )

# Add Loess Fit for Flexible Calibration Line
loess_fit <- loess(observed ~ predicted, data = calib_data, span = 0.75)
calib_data$loess_pred <- predict(loess_fit, calib_data$predicted)

# Plot Calibration Curve with Error Bars
calib_error_bar_lasso = ggplot(calib_data) +
  geom_abline(intercept = 0, slope = 1, color = "red") +
  geom_errorbar(aes(x = predicted, ymin = observed - 1.96 * se,
                    ymax = observed + 1.96 * se),
                colour="black", width=.01)+
  geom_point(aes(x = predicted, y = observed)) +
  labs(x = "Expected Probability of Smoking Abstinence",
       y = "Actual Smoking Abstinence") +
  theme_minimal()


# Plot Calibration Curve with Loess
calib_data <- calib_data %>%
  mutate(loess_ci_lower = loess_pred - 1.96 * sd(loess_pred),
         loess_ci_upper = loess_pred + 1.96 * sd(loess_pred))

calib_loess_lasso = ggplot(calib_data, aes(x = predicted, y = observed)) +
  # Flexible calibration (Loess)
  geom_line(aes(y = loess_pred), color = "black", linetype = "dashed") +  
  geom_ribbon(aes(ymin = loess_ci_lower, ymax = loess_ci_upper), 
              alpha = 0.2, fill = "grey") +
  geom_abline(intercept = 0, slope = 1, color = "red") + # Perfect calibration line
  labs(x = "Predicted Probability of Smoking Abstinence",
       y = "Actual Smoking Abstinence") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))
```


```{r}
# ROC/AUC
predicted_prob_logistic <- predict(logistic_model,
                                newdata = test_data,
                                type = "response")

# Convert predictions to numeric if needed (glmnet returns a matrix)
predicted_prob_logistic <- as.numeric(predicted_prob_logistic)

# Plot ROC and calculate AUC
# Generate ROC object
roc_obj <- roc(test_outcome, predicted_prob_logistic)

# Convert the ROC object to a data frame for ggplot2
roc_data <- data.frame(
  Specificity = rev(roc_obj$specificities),
  Sensitivity = rev(roc_obj$sensitivities)
)

# Calculate the AUC
auc_value <- auc(roc_obj)

# Plot ROC curve with ggplot2
ROC_step = ggplot(roc_data, aes(x = 1-Specificity, y = Sensitivity)) +
  geom_line(color = "purple", size = 1) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "grey") +
  annotate("text", x = 0.8, y = 0.2, label = paste("AUC =", 
                                                   round(auc_value, 2)), 
           size = 5, color = "Black") + labs(
    x = "1 - Specificity",
    y = "Sensitivity"
  ) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```


```{r, fig.width = 12, fig.height = 4}
# Calibration Plots
num_cuts <- 10  # Number of bins for calibration

calib_data <- data.frame(
  prob = predicted_prob_logistic,  # predicted probabilities
  # binning into `num_cuts` groups
  bin = cut(predicted_prob_logistic, breaks = num_cuts),  
  # observed values (abst outcome in test data)
  class = as.numeric(test_outcome)-1  
)

calib_data <- calib_data %>%
  group_by(bin) %>%
  summarise(
    observed = mean(class),  
    predicted = mean(prob),  
    se = sqrt(observed * (1 - observed) / n())  # Standard error
  )

# Add Loess Fit for Flexible Calibration Line
loess_fit <- loess(observed ~ predicted, data = calib_data, span = 0.75)
calib_data$loess_pred <- predict(loess_fit, calib_data$predicted)

# Plot Calibration Curve with Error Bars
calib_error_bar_step = ggplot(calib_data) +
  geom_abline(intercept = 0, slope = 1, color = "red") +
  geom_errorbar(aes(x = predicted, ymin = observed - 1.96 * se,
                    ymax = observed + 1.96 * se),
                colour="black", width=.01)+
  geom_point(aes(x = predicted, y = observed)) +
  labs(x = "Expected Probability of Smoking Abstinence",
       y = "Actual Smoking Abstinence") +
  theme_minimal()


# Plot Calibration Curve with Loess
calib_data <- calib_data %>%
  mutate(loess_ci_lower = loess_pred - 1.96 * sd(loess_pred),
         loess_ci_upper = loess_pred + 1.96 * sd(loess_pred))

calib_loess_step = ggplot(calib_data, aes(x = predicted, y = observed)) +
  # Flexible calibration (Loess)
  geom_line(aes(y = loess_pred), color = "black", linetype = "dashed") +  
  geom_ribbon(aes(ymin = loess_ci_lower, ymax = loess_ci_upper), 
              alpha = 0.2,
              fill = "grey") +
  geom_abline(intercept = 0, slope = 1, color = "red") +  
  # Perfect calibration line
  labs(x = "Predicted Probability of Smoking Abstinence",
       y = "Actual Smoking Abstinence") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))
```

```{r}
# ROC/AUC
predict_best_subset <- function(test_data = test_variables_dummy_include,
                                best_subset_coefs) {
  intercept <- best_subset_coefs[1]
  selected_vars <- names(best_subset_coefs)[-1]
 
  test_subset <- test_data[, selected_vars, drop = FALSE]  
 
  # Calculate predictions by multiplying test data with coefficients
  # Matrix multiplication for predictors + intercept
  predictions <- intercept + as.matrix(test_subset) %*% best_subset_coefs[selected_vars]
 
  return(predictions)
}

predicted_prob_best_subset <- predict_best_subset(test_data = test_variables_dummy_include,
                                   best_subset_coefs)
# Convert predictions to numeric
predicted_prob_best_subset <- as.numeric(predicted_prob_best_subset) -1

# Plot ROC and calculate AUC
# Generate ROC object
roc_obj <- roc(test_outcome, predicted_prob_best_subset)

# Convert the ROC object to a data frame for ggplot2
roc_data <- data.frame(
  Specificity = rev(roc_obj$specificities),
  Sensitivity = rev(roc_obj$sensitivities)
)

# Calculate the AUC
auc_value <- auc(roc_obj)

# Plot ROC curve with ggplot2
ROC_best_subset = ggplot(roc_data, aes(x = 1-Specificity, y = Sensitivity)) +
  geom_line(color = "purple", size = 1) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "grey") +
  annotate("text", x = 0.8, y = 0.2,
           label = paste("AUC =", round(auc_value, 2)), size = 5, color = "Black") +
  labs(
    x = "1 - Specificity",
    y = "Sensitivity"
  ) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        plot.subtitle = element_text(hjust = 0.5))
```


```{r, fig.width = 12, fig.height = 4}
# Calibration plots
num_cuts <- 10  # Number of bins for calibration

calib_data <- data.frame(
  prob = predicted_prob_best_subset,  # predicted probabilities
  # binning into `num_cuts` groups
  bin = cut(predicted_prob_logistic, breaks = num_cuts),  
  # observed values (abst outcome in test data)
  class = as.numeric(test_outcome)-1  
)

calib_data <- calib_data %>%
  group_by(bin) %>%
  summarise(
    observed = mean(class),  
    predicted = mean(prob),  
    se = sqrt(observed * (1 - observed) / n())  # Standard error
  )

# Add Loess Fit for Flexible Calibration Line
loess_fit <- loess(observed ~ predicted, data = calib_data, span = 0.75)
calib_data$loess_pred <- predict(loess_fit, calib_data$predicted)

# Plot Calibration Curve with Error Bars
calib_error_bar_bss = ggplot(calib_data) +
  geom_abline(intercept = 0, slope = 1, color = "red") +
  geom_errorbar(aes(x = predicted, ymin = observed - 1.96 * se,
                    ymax = observed + 1.96 * se),
                colour="black", width=.01)+
  geom_point(aes(x = predicted, y = observed)) +
  labs(x = "Expected Probability of Smoking Abstinence",
       y = "Actual Smoking Abstinence") +
  theme_minimal()
 

# Plot Calibration Curve with Loess
calib_data <- calib_data %>%
  mutate(loess_ci_lower = loess_pred - 1.96 * sd(loess_pred),
         loess_ci_upper = loess_pred + 1.96 * sd(loess_pred))

calib_loess_bss = ggplot(calib_data, aes(x = predicted, y = observed)) +
  # Flexible calibration (Loess)
  geom_line(aes(y = loess_pred), color = "blue", linetype = "dashed") +  
  geom_ribbon(aes(ymin = loess_ci_lower, ymax = loess_ci_upper), alpha = 0.2, fill = "grey") +
  geom_abline(intercept = 0, slope = 1, color = "red") +  # Perfect calibration line
  labs(x = "Predicted Probability of Smoking Abstinence",
       y = "Actual Smoking Abstinence") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

```

```{r, fig.width = 12, fig.height =12}
# Create the 3x3 plot "matrix"
plots_step = arrangeGrob(
  calib_error_bar_step, calib_loess_step, ROC_step,
  ncol = 3,
  left = textGrob("Stepwise Selection", rot = 90,
                 gp = gpar(fontface = "bold", fontsize = 16)
))

plots_lasso = arrangeGrob(
  calib_error_bar_lasso, calib_loess_lasso, ROC_lasso,
  ncol = 3,
  left = textGrob("Lasso Regression", rot = 90,
                 gp = gpar(fontface = "bold", fontsize = 16)
))

plots_bss = arrangeGrob(
  calib_error_bar_bss, calib_loess_bss, ROC_best_subset,
  ncol = 3,
  left = textGrob("Best Subset Selection", rot = 90,
                 gp = gpar(fontface = "bold", fontsize = 16)
))

# Bold the main title
main_title <- textGrob(
  "Calibration Plots with Error Bars and LOESS - ROC Curves (for the 3 Selection Models)",
  gp = gpar(fontface = "bold", fontsize = 18)
)

# Arrange everything with the bold title
grid.arrange(
  plots_lasso,
  plots_step,
  plots_bss,
  nrow = 3,
  top = main_title
)
```


# Results

# Conclusions and Limitations

# Data Privacy and Code Availability

The analysis dataset was obtained from..... The replication code can be found at <https://github.com/AristofanisR/Practical_Data_Analysis_Project2>

\newpage

# References

::: {#refs}
:::

\newpage

# Code Appendix

```{r ref.label = knitr::all_labels(), echo = TRUE, eval = FALSE}
```
